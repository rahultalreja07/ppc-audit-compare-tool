<!-- Generated by Copilot -->
<!-- GppTab: GPP time-series charts: Price, Dividend, ClassTNA (per-class section format) -->
<template>
  <div class="space-y-8">
    <!-- Status row -->
    <div class="flex items-center gap-3">
      <span class="text-sm text-gray-500">GPP Status:</span>
      <StatusBadge :status="gpp.status" />
      <span v-if="gpp.data_source" class="text-xs text-gray-400 ml-2">Source: {{ dataSourceLabel }}</span>
    </div>

    <!-- Section availability badges -->
    <div class="flex flex-wrap gap-2">
      <span
        v-for="sec in knownSections"
        :key="sec"
        :class="[
          'text-xs px-2 py-1 rounded border font-mono',
          gpp.sections[sec]?.length ? 'bg-green-50 border-green-300 text-green-800' : 'bg-red-50 border-red-300 text-red-700',
        ]"
      >
        {{ sec }}
      </span>
    </div>

    <!-- A chart for each available section -->
    <div v-for="(points, sectionName) in gpp.sections" :key="sectionName" class="bg-white rounded-lg border border-gray-200 p-4">
      <h3 class="text-sm font-semibold text-gray-700 mb-3">{{ sectionName }}</h3>
      <div class="h-52">
        <Line
          v-if="points && points.length"
          :data="chartData(String(sectionName), points)"
          :options="chartOptions"
        />
        <p v-else class="text-sm text-gray-400 italic">No data available</p>
      </div>
    </div>

    <!-- Missing sections note -->
    <div v-if="missingSections.length" class="text-xs text-gray-400 italic">
      Missing expected sections: {{ missingSections.join(', ') }}
    </div>
  </div>
</template>

<script setup lang="ts">
import { Line } from 'vue-chartjs'
import {
  Chart as ChartJS,
  CategoryScale,
  LinearScale,
  PointElement,
  LineElement,
  Title,
  Tooltip,
  Legend,
  Filler,
} from 'chart.js'
import type { ChartData, ChartOptions } from 'chart.js'
import type { ComparisonDetail, GppSectionEntry } from '~/types/comparison'

ChartJS.register(CategoryScale, LinearScale, PointElement, LineElement, Title, Tooltip, Legend, Filler)

const props = defineProps<{
  gpp: ComparisonDetail['gpp_data']
}>()

// Known sections (replaces removed expected_sections field)
const knownSections = ['Price', 'Dividend', 'CapitalGain', 'DailyDividend', 'ClassTNA']

const missingSections = computed(() =>
  knownSections.filter(s => !props.gpp.sections?.[s]?.length)
)

// Friendly data_source label for both string and object formats
const dataSourceLabel = computed(() => {
  const ds = props.gpp.data_source
  if (!ds) return null
  if (typeof ds === 'object') return Object.values(ds as Record<string, string>).join(', ')
  return String(ds)
})

// Build per-class datasets from new { PerformanceId, Date, "Class X": value } format
const PALETTE = ['#3B82F6', '#8B5CF6', '#14B8A6', '#F59E0B', '#EF4444', '#10B981']

function chartData(sectionName: string, points: GppSectionEntry[]): ChartData<'line'> {
  if (!points?.length) return { labels: [], datasets: [] }

  // Collect all class keys (everything except PerformanceId and Date)
  const classKeySet = new Set<string>()
  for (const p of points) {
    for (const k of Object.keys(p)) {
      if (k !== 'PerformanceId' && k !== 'Date') classKeySet.add(k)
    }
  }
  const classKeys = Array.from(classKeySet)

  // One dataset per class
  const datasets = classKeys.map((cls, i) => ({
    label: String(cls),
    data: points
      .filter(p => p[cls] != null)
      .map(p => p[cls] as number),
    borderColor: PALETTE[i % PALETTE.length],
    backgroundColor: PALETTE[i % PALETTE.length] + '18',
    fill: false,
    tension: 0.3,
    pointRadius: 3,
    spanGaps: true,
  }))

  // Labels: deduplicated dates for the section
  const labels = Array.from(new Set(points.map(p => p.Date)))

  return { labels, datasets }
}

const chartOptions: ChartOptions<'line'> = {
  responsive: true,
  maintainAspectRatio: false,
  plugins: {
    legend: { display: false },
    tooltip: { mode: 'index', intersect: false },
  },
  scales: {
    x: {
      ticks: { maxTicksLimit: 10, maxRotation: 30 },
      grid: { display: false },
    },
    y: {
      ticks: { maxTicksLimit: 6 },
    },
  },
}
</script>
